# Determina se il byte in ingresso è compreso
# nell'intervallo [7, 8].
# Assume che il byte sia codificato in virgola
# fissa con 4 bit dedicati alla parte intera.
.model NEUTRAL

# Accetta un input: un byte da elaborare.
# Risponde con UNO se il byte è compreso
# nell'intervallo [7, 8], altrimenti ZERO.
.inputs  VAL7 VAL6 VAL5 VAL4 VAL3 VAL2 VAL1 VAL0
.outputs RES

# Valori costanti.
.subckt ZERO RES=0
.subckt ONE  RES=1

# Determina se il byte in ingresso è minore di SETTE.
.subckt LT8 A7=VAL7 A6=VAL6 A5=VAL5 A4=VAL4 A3=VAL3 A2=VAL2 A1=VAL1 A0=VAL0 B7=0 B6=1 B5=1 B4=1 B3=0 B2=0 B1=0 B0=0 RES=LOWER

# Determina se il byte in ingresso è maggiore di OTTO.
.subckt GT8 A7=VAL7 A6=VAL6 A5=VAL5 A4=VAL4 A3=VAL3 A2=VAL2 A1=VAL1 A0=VAL0 B7=1 B6=0 B5=0 B4=0 B3=0 B2=0 B1=0 B0=0 RES=GREATER

# Se il byte in ingresso non rispetta alcuna delle due
# condizioni precedenti, allora sia LOWER che GREATER
# equivalgono a ZERO, di conseguenza utilizzando una
# porta nor otteniamo in risposta un bit equivalente
# ad UNO se è compreso nell'intervallo, altrimenti ZERO.
.subckt NOR A=LOWER B=GREATER RES=RES

.end

# Ricerca dei modelli ZERO, ONE, NOR, LT8, GT8.
.search zero.blif
.search one.blif
.search nor.blif
.search lt8.blif
.search gt8.blif
