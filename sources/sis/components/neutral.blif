# Determina se il byte in ingresso è compreso
# nell'intervallo [7, 8].
# Assume che il byte sia codificato in virgola
# fissa con 4 bit dedicati alla parte intera.
.model NEUTRAL

# Accetta un input: un byte da elaborare.
# Risponde con UNO se il byte è compreso
# nell'intervallo [7, 8], altrimenti ZERO.
.inputs  I7 I6 I5 I4 I3 I2 I1 I0
.outputs RES

# Valori costanti.
.subckt ZERO RES=0
.subckt ONE  RES=1

# Determina se il byte in ingresso è minore di SETTE.
.subckt LT8 A7=I7 A6=I6 A5=I5 A4=I4 A3=I3 A2=I2 A1=I1 A0=I0 B7=0 B6=1 B5=1 B4=1 B3=0 B2=0 B1=0 B0=0 RES=LOWER

# Determina se il byte in ingresso è maggiore di OTTO.
.subckt GT8 A7=I7 A6=I6 A5=I5 A4=I4 A3=I3 A2=I2 A1=I1 A0=I0 B7=1 B6=0 B5=0 B4=0 B3=0 B2=0 B1=0 B0=0 RES=GREATER

# Se il byte in ingresso non rispetta alcuna delle due
# condizioni precedenti, allora sia LOWER che GREATER
# equivalgono a ZERO, di conseguenza utilizzando una
# porta nor otteniamo in risposta un bit equivalente
# ad UNO se è compreso nell'intervallo, altrimenti
# ZERO.
.subckt NOR A=LOWER B=GREATER RES=RES

.end

# Ricerca dei modelli ZERO, ONE, NOR, LT8, GT8.
.search zero.blif
.search one.blif
.search nor.blif
.search lt8.blif
.search gt8.blif
